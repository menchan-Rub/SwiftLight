---
description: Rules
globs: 
---


# SwiftLight言語開発のためのプロジェクトルール

##
- 発生しているエラー修正をしてから次の実装に行くこと。

## タスク分析ガイドライン

### 開発時の分析プロセス
各機能実装前に以下の分析を行うこと:
- SwiftLight言語仕様書に定義された要件との整合性確認
- メモリ安全性、並行処理、メタプログラミングへの影響を評価
- 既存実装との重複チェックと共通化検討
- 依存関係の特定と最小化

### 重複実装の防止
実装前に必ず以下を確認:
- 既存コンポーネントとの機能重複の有無
- 類似名の関数、型、モジュールの存在
- 標準ライブラリとの重複
- 共通処理の抽出可能性

## 技術要件

### コンパイラ実装
- **実装言語**: Rust（最新の安定版）
- **バックエンド**: LLVM（カスタマイズ可）
- **最適化レベル**: 極限の最適化を追求
- **並列処理**: インクリメンタル・並列コンパイルを実装

### メモリ管理
- **安全性**: 所有権/借用システムによる100%の安全性保証
- **効率性**: ゼロコスト抽象化の徹底
- **検証**: 静的解析による完全検証

### 品質管理
- **テストカバレッジ**: 95%以上を目標
- **ファジングテスト**: 字句解析・構文解析に特に重点
- **形式手法**: 重要部分には形式的検証を適用

# コーディング規約（改善版）

## 命名規則

### 型名
- PascalCase（例: TypeChecker, CodeGenerator）
- ジェネリック型パラメータは単一大文字または意味のあるPascalCase（例: T, Key, Element）
- トレイト/インターフェースは能力を表す名詞または形容詞（例: Serializable, Iterator）

### 関数名・変数名
- snake_case（例: parse_expression, type_inference）
- ブール値を返す関数はis_, has_, can_などで始める（例: is_valid, has_errors）
- 変換関数はto_, into_, from_などで始める（例: to_string, into_ir）

### その他
- 定数: SCREAMING_SNAKE_CASE（例: MAX_RECURSION_DEPTH）
- モジュール名: snake_case（例: type_system, code_gen）
  - 単一の責任原則に基づいて命名（例: name_resolution）
- マクロ名: snake_case!（例: define_type!, generate_parser!）
- フィールド名: snake_case（例: node_count, source_location）
- 列挙型のバリアント: PascalCase（例: TokenType::Identifier, Error::SyntaxError）

## コード構造

### ファイル編成
- 1ファイルにつき1つの主要な型または密接に関連した型群
- ファイルの最大行数は500行を目標（超える場合は分割を検討）
- 論理的なインポート順序: 標準ライブラリ → 外部クレート → 内部モジュール

### 型の宣言順序
1. 公開定数
2. 公開型
3. トレイト実装
4. 公開関数
5. 内部定数/型/関数

### 関数構造
- 早期リターンパターンを活用
- ガード句を使用して特殊ケースを先に処理
- 複雑な条件はnamed booleanへの分解を推奨

## コード品質メトリクス

### 複雑度
- 関数の循環的複雑度は8以下を目標（超える場合は関数分割）
- 認知的複雑度は15以下を目標

### 関数サイズ
- 30行以下を目標（テスト関数を除く）
- 引数は4つ以下を推奨（多い場合は構造体に集約）

### ネスト
- 3レベル以上のネストは避ける
- 複雑なネストは早期リターンや関数抽出で単純化

### コードカバレッジ
- ステートメントカバレッジ: 95%以上
- 分岐カバレッジ: 90%以上
- 条件カバレッジ: 85%以上

## コードスタイル（詳細）

### フォーマット
- インデント: 4スペース（タブ不可）
- 行の最大長: 100文字
- 関数呼び出しの引数が複数行の場合、各引数は独立した行に
- 制御構文の括弧は常に中括弧を使用（単文の場合も）
- 演算子の前後にスペース（例: x + y）
- カンマの後にスペース（例: fn example(a: i32, b: String)）

### 空白行
- 論理的なコードブロック間に1行
- 関数/メソッド間に2行
- 型宣言間に2行

### アクセス修飾子の順序
- pub(crate) → pub → pub(super) → デフォルト（内部）

## エラー処理と例外安全性

### エラー型設計
- 意味のある独自エラー型を定義（例: CompilerError, TypeCheckError）
- エラーは常に詳細なコンテキスト情報を含む（ソース位置、関連識別子など）
- エラーチェインを活用し、根本原因の追跡を容易に

### 結果返却
- パニックは初期化フェーズと修復不可能なエラーのみに限定
- 公開APIはすべてResultまたはOptionを返す
- エラー伝播演算子（?）を適切に活用
- unwrap()/expect()の使用は厳密に禁止（テストコードを除く）

## メモリ管理と安全性

### 所有権と借用
- 不必要なクローンを避ける（必要な場合は明示的なコメントで理由を説明）
- 複雑な借用パターンは避け、必要な場合は詳細にコメント
- ライフタイムパラメータは意味のある名前を使用（例: 'src, 'ast）

### リソース管理
- RAII原則を厳守
- リソースリークを防ぐためにデストラクタを適切に実装
- ファイルやネットワーク接続などはDropトレイトでの自動クリーンアップを保証

### unsafe実践
- unsafeブロックは専用コメントブロックで正当化（形式: /* SAFETY: ... */）
- 不変条件を明示
- コードレビューではunsafeを使用するPRに特別な注意を払う
- unsafeのユニットテストは網羅的なエッジケースをカバー

## ドキュメンテーション

### コメント形式
- 公開API: Rustdocスタイル（///）のフル文書化
- 内部関数: 目的と前提条件/事後条件を簡潔に説明
- 複雑なアルゴリズム: アルゴリズムの原理と選択理由を説明

### API文書要件
- 各公開項目には少なくとも1行の説明
- パラメータとリターン値の完全な説明
- 発生しうるエラーと条件の文書化
- 使用例のコードスニペット
- パフォーマンスに関する注記（時間/空間複雑性）

### コード内のドキュメント
- 「なぜ」に焦点を当てたコメント（「何を」はコード自体で明らかにする）
- TODOコメントには理由と優先度を含める（例: // TODO(high): 最適化が必要 - 現在O(n²)だが理想はO(n log n)）
- トリッキーな実装には参考資料（論文、ブログ記事など）へのリンク

## テスト規約

### テスト構造
- 準備（Arrange）、実行（Act）、検証（Assert）パターンを使用
- テストケース名はtest_[テスト対象の機能]_[テスト条件]_[期待される結果]
- テストヘルパー関数を活用して重複を減らす

### テスト種類
- ユニットテスト: 単一機能の動作を検証
- プロパティテスト: 不変条件と属性を検証
- 回帰テスト: 過去に修正されたバグの再発防止
- パフォーマンステスト: クリティカルパスのパフォーマンス確認

### 境界テスト
- エッジケースの体系的検証（空入力、最大値、無効入力など）
- 異常系テストを正常系と同等以上に重視

## パフォーマンス考慮事項

### アロケーション
- ホットパスでの動的アロケーションを最小化
- バッファ再利用パターンを適用
- アリーナアロケーションを活用（特にコンパイラのAST構築など）

### アルゴリズム選択
- 実装前にアルゴリズムの時間/空間複雑性を文書化
- O(n²)以上の複雑性を持つアルゴリズムは正当化が必要
- メモリ使用量への意識（特に大規模入力処理時）

### キャッシュ効率
- データ局所性を考慮した構造体設計
- ホットパスでのキャッシュライン最適化

## 並行処理

### 同期プリミティブ
- 最小権限の原則に基づく同期プリミティブ選択
- デッドロック防止のためのロック順序の厳格な文書化
- 細粒度ロックよりもデータ分割を優先

### スレッドセーフティ
- スレッドセーフな型はSendとSyncを明示的に実装
- 内部可変性を持つ型はスレッドセーフティを文書化
- 並行アクセス問題はできるだけコンパイル時に捕捉

## プロジェクト管理拡張

### コードレビュープロセス

#### レビュー焦点領域
- アルゴリズムの正確性と効率
- エラー処理の網羅性
- エッジケースの考慮
- メモリ安全性の保証
- コードの可読性と保守性

#### レビューチェックリスト
- 仕様要件を満たしているか
- 既存テストが通過するか
- 新機能には適切なテストが追加されているか
- パフォーマンス回帰はないか
- 既存APIとの一貫性は保たれているか

### コードリファクタリング

#### リファクタリング基準
- 同じパターンが3回以上繰り返される場合は抽象化
- メソッド/関数が複数の責任を持つ場合は分割
- 循環的依存がある場合は再構築

#### リファクタリングプロセス
- リファクタリングと機能追加は別PRで実施
- リファクタリング前後のパフォーマンスベンチマーク比較
- リファクタリングの理由と戦略を明確に文書化

### 技術的負債管理

#### 負債の特定
- コードベース分析ツールによる定期的なホットスポット特定
- 「負債」コメントの体系的な追跡（例: // DEBT: この実装はO(n²)で最適化が必要）

#### 負債返済計画
- 四半期ごとの技術的負債専用スプリント
- 負債項目の優先順位付け（影響範囲、頻度、重大度による）

### 継続的改善プロセス

#### コード品質メトリクス追跡
- 定期的な静的解析レポート生成
- コードカバレッジトレンド分析
- 複雑度ホットスポットの特定と改善

#### 知識共有
- コードウォークスルーセッションの定期開催
- アーキテクチャ決定記録（ADR）の維持
- 実装パターンとアンチパターンのカタログ作成

#### ツールと自動化
- カスタムlintルールの開発
- 特定のエラーパターン検出のための静的解析拡張
- コードレビュー自動化支援ツール

## 開発プロセス

### ブランチ戦略
- **main**: 安定版・リリース用（直接コミット禁止）
- **develop**: 開発統合用
- **feature/[name]**: 機能開発用
- **bugfix/[name]**: バグ修正用
- **release/[version]**: リリース準備用

### コミットメッセージ形式
```
[コンポーネント] 変更内容の要約（命令形、50文字以内）

- 変更の詳細説明（箇条書きまたは段落形式）
- 必要に応じて関連する言語仕様書の参照
- 影響範囲やテスト状況
```

### プルリクエスト
- すべての変更はPR経由で実施
- 最低2名のレビュアーによる承認が必要
- CI通過が必須
- コードカバレッジの低下は認めない

### レビュー基準
- メモリ安全性の保証
- 言語仕様書との整合性
- パフォーマンス影響
- エラーメッセージの品質
- テストの網羅性

## テスト要件

### テスト種別と要件
- **単体テスト**: すべての公開関数・メソッドに対する単体テストを必須
- **統合テスト**: コンパイラパイプライン全体の整合性をテスト
- **パフォーマンステスト**: コンパイル速度、実行速度のベンチマークを実装
- **ファジングテスト**: 特に構文解析と型チェックにファジングを適用
- **プロパティベーステスト**: 型システム、最適化の正当性検証に使用

### テスト命名規則
テストファイル名は `[対象]_test.rs` とし、テスト関数名は `test_[検証内容]` とする

### テストデータ
- 実例に基づくテストケース
- エッジケースの網羅
- 大規模プロジェクトでの検証

## ドキュメント要件

### ドキュメント種別
- **APIドキュメント**: すべての公開機能に対する詳細な説明
- **言語仕様書**: 正確で網羅的な言語仕様の維持
- **チュートリアル**: 段階的な学習ガイド
- **サンプルコード**: すべての言語機能に対する実例

### ドキュメント更新ルール
- コード変更を伴うPRには必ずドキュメント更新も含める
- 複雑な機能には図や表を用いた説明を追加
- エラーメッセージには解決策の例を含める
---

# 技術スタック

[technologystack.md](mdc:.cursor/rule/technologystack.md)

---
# ディレクトリ構成

[directorystructure.md](mdc:.cursor/rule/directorystructure.md)

# 仕様書

[specification.md](mdc:.cursor/rule/specification.md)

# その他
- すでにファイルは全て作ってあるので、新規作成することを禁じる。

## 品質保証

### CI/CDパイプライン
- ビルド検証
- 全テスト実行
- 静的解析
- ドキュメント生成
- ベンチマーク実行と履歴比較

### セキュリティ検証
- 依存ライブラリの脆弱性スキャン
- `unsafe`コードの特別レビュー
- セキュリティ専門家による定期監査

### パフォーマンス検証
- コンパイル時間の上限設定（目標: 1MLOC/分）
- 実行時パフォーマンスベンチマーク
- メモリ使用量の監視