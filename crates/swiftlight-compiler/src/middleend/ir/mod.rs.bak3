// SwiftLight IR生成モジュール
//
// このモジュールは、AST（抽象構文木）からLLVM IRを生成するための
// 中間表現とユーティリティを提供します。

pub mod representation;

use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use inkwell::{
    context::Context,
    module::Module as LLVMModule,
    builder::Builder,
    values::{FunctionValue, BasicValueEnum, PointerValue, AnyValueEnum, IntValue, FloatValue, BasicValue},
    types::{BasicTypeEnum, BasicType, AnyTypeEnum, StructType, FunctionType},
    basic_block::BasicBlock as LLVMBasicBlock,
    AddressSpace,
};
use inkwell::values::BasicMetadataValueEnum;
use crate::frontend::ast::{self, Program, Declaration, Statement, Expression, NodeId, TypeAnnotation, TypeKind};
use crate::frontend::ast::{ExpressionKind, StatementKind, DeclarationKind, Identifier, Function as AstFunction};
use crate::frontend::ast::{VariableDeclaration, ConstantDeclaration, Parameter, Struct, Enum, Trait};
use crate::frontend::ast::{TypeAlias, Implementation, Import, BinaryOperator, UnaryOperator, Literal, LiteralKind};
use crate::frontend::error::{Result, CompilerError, Diagnostic, SourceLocation};
use crate::frontend::semantic::type_checker::TypeCheckResult;

// 公開型の再エクスポート
pub use representation::{Module, Function, BasicBlock, Instruction, Value, Type, Operand, OpCode};

/// LLVM IR生成器
pub struct IRGenerator<'ctx> {
    /// LLVM コンテキスト
    context: &'ctx Context,
    
    /// LLVM モジュール
    llvm_module: LLVMModule<'ctx>,
    
    /// LLVM IR ビルダー
    builder: Builder<'ctx>,
    
    /// 型チェック結果（ノードの型情報）
    type_info: TypeCheckResult,
    
    /// 生成中のモジュール
    module: Module,
    
    /// 値のマッピング（AST ノードID -> IR 値）
    values: HashMap<NodeId, Value>,
    
    /// 基本ブロックのマッピング（SwiftLight関数ID -> 基本ブロックのリスト）
    blocks: HashMap<String, Vec<BasicBlock>>,
    
    /// 現在の関数の値
    current_function: Option<FunctionValue<'ctx>>,
    
    /// 現在の基本ブロック
    current_block: Option<LLVMBasicBlock<'ctx>>,
    
    /// ローカル変数のマッピング（変数名 -> LLVM ポインタ値）
    variables: HashMap<String, PointerValue<'ctx>>,
    
    /// 関数のマッピング（関数名 -> LLVM 関数値）
    functions: HashMap<String, FunctionValue<'ctx>>,
    
    /// 構造体のマッピング（構造体名 -> LLVM 構造体型）
    structs: HashMap<String, StructType<'ctx>>,
    
    /// 一時変数カウンタ（一意な名前生成用）
    temp_counter: usize,
    
    /// エラー情報
    errors: Vec<CompilerError>,
    
    /// デバッグ情報有効フラグ
    debug_info: bool,
    
    /// 現在のループの条件ブロック（continue先）
    current_loop_condition: Option<LLVMBasicBlock<'ctx>>,
    
    /// 現在のループの終了ブロック（break先）
    current_loop_exit: Option<LLVMBasicBlock<'ctx>>,
    
    /// 現在の例外ハンドラ情報
    current_exception_handler: Option<(PointerValue<'ctx>, PointerValue<'ctx>, LLVMBasicBlock<'ctx>)>,
    
    /// ジェネリック関数の型パラメータ
    current_type_parameters: HashMap<String, TypeAnnotation>,
}

impl<'ctx> IRGenerator<'ctx> {
    /// 新しいIRジェネレーターを作成
    pub fn new(type_info: &TypeCheckResult) -> Self {
        let context = Context::create();
        let module_name = "swiftlight_module";
        let llvm_module = context.create_module(module_name);
        let builder = context.create_builder();
        
        Self {
            context: &context,
            llvm_module,
            builder,
            type_info: type_info.clone(),
            module: Module::new(module_name),
            values: HashMap::new(),
            blocks: HashMap::new(),
            current_function: None,
            current_block: None,
            variables: HashMap::new(),
            functions: HashMap::new(),
            structs: HashMap::new(),
            temp_counter: 0,
            errors: Vec::new(),
            debug_info: true,
            current_loop_condition: None,
            current_loop_exit: None,
            current_exception_handler: None,
            current_type_parameters: HashMap::new(),
        }
    }
    
    /// 生成中にエラーを追加
    fn add_error(&mut self, message: impl Into<String>, location: Option<SourceLocation>) {
        self.errors.push(CompilerError::code_generation_error(message, location));
    }
    
    /// 一時変数名を生成
    fn generate_temp_name(&mut self, prefix: &str) -> String {
        let name = format!("{}.{}", prefix, self.temp_counter);
        self.temp_counter += 1;
        name
    }
    
    /// プログラムからIRモジュールを生成
    pub fn generate_module(&mut self, program: &Program) -> Result<Module> {
        // 初期化
        self.initialize_module(program)?;
        
        // 型定義の事前宣言（相互参照を解決するため）
        self.predeclare_types(program)?;
        
        // 関数シグネチャの事前宣言（相互参照を解決するため）
        self.predeclare_functions(program)?;
        
        // 宣言処理
        for declaration in &program.declarations {
            if let Err(e) = self.generate_declaration(declaration) {
                self.errors.push(e);
            }
        }
        
        // トップレベルの文を処理
        let entry_fn = self.generate_program_entry(program)?;
        
        // モジュールのクリーンアップと検証
        self.finalize_module()?;
        
        // エラーがあれば報告
        if !self.errors.is_empty() {
            let err_msg = format!("{} errors occurred during IR generation", self.errors.len());
            return Err(CompilerError::code_generation_error(err_msg, None).with_cause(self.errors[0].clone()));
        }
        
        Ok(self.module.clone())
    }
    
    /// モジュール初期化
    fn initialize_module(&mut self, program: &Program) -> Result<()> {
        // モジュール名を設定（ファイル名ベース）
        let module_name = program.file_name.clone();
        self.module.name = module_name.clone();
        self.module.set_source_file(program.file_name.clone());
        
        // LLVM データレイアウトの設定
        self.llvm_module.set_data_layout("e-m:e-i64:64-f80:128-n8:16:32:64-S128");
        
        // ターゲットトリプルの設定
        self.llvm_module.set_triple("x86_64-unknown-linux-gnu");
        
        // 標準ライブラリ関数の宣言
        self.declare_runtime_functions()?;
        
        Ok(())
    }
    
    /// ランタイム関数の宣言
    fn declare_runtime_functions(&mut self) -> Result<()> {
        // println関数の宣言 (void println(char*))
        let void_type = self.context.void_type();
        let str_type = self.context.i8_type().ptr_type(AddressSpace::Generic);
        let println_type = void_type.fn_type(&[str_type.into()], false);
        let println_fn = self.llvm_module.add_function("println", println_type, None);
        self.functions.insert("println".to_string(), println_fn);
        
        // メモリ操作関数の宣言
        // malloc: void* malloc(size_t)
        let i64_type = self.context.i64_type();
        let ptr_type = self.context.i8_type().ptr_type(AddressSpace::Generic);
        let malloc_type = ptr_type.fn_type(&[i64_type.into()], false);
        let malloc_fn = self.llvm_module.add_function("malloc", malloc_type, None);
        self.functions.insert("malloc".to_string(), malloc_fn);
        
        // free: void free(void*)
        let free_type = void_type.fn_type(&[ptr_type.into()], false);
        let free_fn = self.llvm_module.add_function("free", free_type, None);
        self.functions.insert("free".to_string(), free_fn);
        
        // memcpy: void* memcpy(void* dest, void* src, size_t n)
        let memcpy_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), i64_type.into()], false);
        let memcpy_fn = self.llvm_module.add_function("memcpy", memcpy_type, None);
        self.functions.insert("memcpy".to_string(), memcpy_fn);
        
        // 基本的な数学関数の宣言
        let f64_type = self.context.f64_type();
        let math_fn_type = f64_type.fn_type(&[f64_type.into()], false);
        
        // double sqrt(double)
        let sqrt_fn = self.llvm_module.add_function("sqrt", math_fn_type, None);
        self.functions.insert("sqrt".to_string(), sqrt_fn);
        
        // double sin(double)
        let sin_fn = self.llvm_module.add_function("sin", math_fn_type, None);
        self.functions.insert("sin".to_string(), sin_fn);
        
        // double cos(double)
        let cos_fn = self.llvm_module.add_function("cos", math_fn_type, None);
        self.functions.insert("cos".to_string(), cos_fn);
        
        // プロファイリングとインストルメンテーション関数を宣言
        self.declare_instrumentation_functions()?;
        
        Ok(())
    }
    
    /// 型定義の事前宣言
    fn predeclare_types(&mut self, program: &Program) -> Result<()> {
        // 構造体宣言を収集し、前方宣言
        for declaration in &program.declarations {
            if let DeclarationKind::Struct(struct_decl) = &declaration.kind {
                let struct_name = &struct_decl.name.name;
                
                // LLVM構造体型の作成（フィールドなしで前方宣言）
                let struct_type = self.context.opaque_struct_type(struct_name);
                self.structs.insert(struct_name.clone().to_owned(), struct_type);
                
                // 中間表現のモジュールにも追加
                self.module.add_struct(struct_name.clone(), Vec::new());
            }
        }
        
        // 構造体フィールドの設定
        for declaration in &program.declarations {
            if let DeclarationKind::Struct(struct_decl) = &declaration.kind {
                let struct_name = &struct_decl.name.name;
                
                if let Some(&struct_type) = self.structs.get(struct_name) {
                    // フィールド型を解決
                    let mut field_types = Vec::new();
                    let mut ir_field_types = Vec::new();
                    
                    for field in &struct_decl.fields {
                        if let Some(field_type) = self.type_info.get_node_type(field.type_annotation.id) {
                            if let Ok(llvm_type) = self.convert_type_from_annotation(&field_type) {
                                field_types.push(llvm_type);
                                
                                // 中間表現の型も収集
                                let ir_type = self.convert_to_ir_type(&field_type)?;
                                ir_field_types.push(ir_type);
                            } else {
                                self.add_error(
                                    format!("構造体 '{}' のフィールド '{}' の型を解決できません", 
                                            struct_name, field.name.name),
                                    field.location.clone()
                                );
                            }
                        } else {
                            self.add_error(
                                format!("構造体 '{}' のフィールド '{}' の型情報がありません", 
                                        struct_name, field.name.name),
                                field.location.clone()
                            );
                        }
                    }
                    
                    // 構造体の本体を設定
                    struct_type.set_body(&field_types, false);
                    
                    // 中間表現の構造体フィールドも更新
                    self.module.structs.insert(struct_name.clone(), ir_field_types);
                }
            }
        }
        
        Ok(())
    }
    
    /// 関数シグネチャの事前宣言
    fn predeclare_functions(&mut self, program: &Program) -> Result<()> {
        for declaration in &program.declarations {
            if let DeclarationKind::Function(func_decl) = &declaration.kind {
                let func_name = &func_decl.name.name;
                
                // 関数の型を解決
                let mut param_types = Vec::new();
                for param in &func_decl.parameters {
                    if let Some(param_type) = self.type_info.get_node_type(param.type_annotation.as_ref().unwrap().id) {
                        if let Ok(llvm_param_type) = self.convert_type_from_annotation(&param_type) {
                            param_types.push(llvm_param_type);
                        } else {
                            self.add_error(
                                format!("関数 '{}' のパラメータ '{}' の型を解決できません", 
                                        func_name, param.name.name),
                                param.location.clone()
                            );
                        }
                    } else {
                        self.add_error(
                            format!("関数 '{}' のパラメータ '{}' の型情報がありません", 
                                    func_name, param.name.name),
                            param.location.clone()
                        );
                    }
                }
                
                // 戻り値型の解決
                let return_type = if let Some(ret_type) = &func_decl.return_type {
                    if let Some(type_info) = self.type_info.get_node_type(ret_type.id) {
                        match self.convert_type_from_annotation(&type_info) {
                            Ok(t) => t,
                            Err(_) => {
                                self.add_error(
                                    format!("関数 '{}' の戻り値型を解決できません", func_name),
                                    ret_type.location.clone()
                                );
                                self.context.void_type().into()
                            }
                        }
                    } else {
                        self.add_error(
                            format!("関数 '{}' の戻り値型情報がありません", func_name),
                            ret_type.location.clone()
                        );
                        self.context.void_type().into()
                    }
                } else {
                    // 戻り値型の指定がない場合はvoid
                    self.context.void_type().into()
                };
                
                // LLVM関数型の作成
                let fn_type = match return_type {
                    BasicTypeEnum::IntType(t) => t.fn_type(&param_types, false),
                    BasicTypeEnum::FloatType(t) => t.fn_type(&param_types, false),
                    BasicTypeEnum::PointerType(t) => t.fn_type(&param_types, false),
                    BasicTypeEnum::StructType(t) => t.fn_type(&param_types, false),
                    BasicTypeEnum::ArrayType(t) => t.fn_type(&param_types, false),
                    _ => self.context.void_type().fn_type(&param_types, false),
                };
                
                // LLVM関数を追加
                let function = self.llvm_module.add_function(func_name, fn_type, None);
                self.functions.insert(func_name.clone().to_owned(), function);
                
                // 中間表現の関数も作成
                let mut ir_function = Function::new(func_name.clone(), self.convert_to_ir_type_from_basic_type(return_type)?);
                
                // パラメータも追加
                for (i, param) in func_decl.parameters.iter().enumerate() {
                    if let Some(param_type) = self.type_info.get_node_type(param.type_annotation.as_ref().unwrap().id) {
                        let ir_param_type = self.convert_to_ir_type(&param_type)?;
                        let ir_param = representation::Parameter::new(
                            param.name.name.clone(),
                            ir_param_type,
                            false // バイ・リファレンスかどうかはここでは判断できない
                        );
                        ir_function.add_parameter(ir_param);
                    }
                }
                
                // 中間表現のモジュールに関数を追加
                self.module.add_function(ir_function);
            }
        }
        
        Ok(())
    }
    
    /// プログラムのエントリーポイントを生成
    fn generate_program_entry(&mut self, program: &Program) -> Result<FunctionValue<'ctx>> {
        // main関数の生成
        let void_type = self.context.void_type();
        let main_type = self.context.i32_type().fn_type(&[], false);
        let main_fn = self.llvm_module.add_function("main", main_type, None);
        
        // エントリーブロックの作成
        let entry_block = self.context.append_basic_block(main_fn, "entry");
        self.builder.position_at_end(entry_block);
        
        // 現在の関数コンテキストを設定
        self.current_function = Some(main_fn);
        self.current_block = Some(entry_block);
        
        // トップレベルの文を処理
        for stmt in &program.statements {
            if let Err(e) = self.generate_statement(stmt) {
                self.errors.push(e);
            }
        }
        
        // main関数の戻り値（成功を示す0）
        let ret_val = self.context.i32_type().const_int(0, false);
        self.builder.build_return(Some(&ret_val));
        
        // 中間表現のmain関数も作成
        let mut ir_main = Function::new("main", Type::Integer(32));
        let mut ir_entry = BasicBlock::new("entry");
        
        // returnの命令を追加
        let ret_inst = Instruction::new(
            OpCode::Return,
            None,
            Type::Void,
            vec![Operand::Constant(Value::Integer(0))],
        );
        ir_entry.add_instruction(ret_inst);
        
        // 基本ブロックを追加
        ir_main.add_block(ir_entry);
        
        // 中間表現のモジュールに追加
        self.module.add_function(ir_main);
        
        Ok(main_fn)
    }
    
    /// モジュールの最終化
    fn finalize_module(&mut self) -> Result<()> {
        // モジュールの検証
        if let Err(err) = self.llvm_module.verify() {
            return Err(CompilerError::code_generation_error(
                format!("LLVM モジュール検証エラー: {}", err),
                None
            ));
        }
        
        Ok(())
    }
    
    /// TypeAnnotationからLLVM型に変換
    fn convert_type_from_annotation(&self, type_ann: &TypeAnnotation) -> Result<BasicTypeEnum<'ctx>> {
        match &type_ann.kind {
            TypeKind::Int => Ok(self.context.i64_type().into()),
            TypeKind::Float => Ok(self.context.f64_type().into()),
            TypeKind::Bool => Ok(self.context.bool_type().into()),
            TypeKind::String => {
                // 文字列はi8のポインタとして表現
                Ok(self.context.i8_type().ptr_type(AddressSpace::Generic).into())
            },
            TypeKind::Char => Ok(self.context.i8_type().into()),
            TypeKind::Void => {
                // voidはLLVMではBasicTypeEnumとして表現できないため、便宜上i8*として扱う
                Err(CompilerError::code_generation_error(
                    "Void型は値として扱えません",
                    type_ann.location.clone()
                ))
            },
            TypeKind::Array(elem_type, _) => {
                if let Some(elem_type_info) = self.type_info.get_node_type(elem_type.id) {
                    let llvm_elem_type = self.convert_type_from_annotation(&elem_type_info)?;
                    
                    // 配列はポインタとして表現
                    match llvm_elem_type {
                        BasicTypeEnum::IntType(t) => Ok(t.ptr_type(AddressSpace::Generic).into()),
                        BasicTypeEnum::FloatType(t) => Ok(t.ptr_type(AddressSpace::Generic).into()),
                        BasicTypeEnum::PointerType(t) => Ok(t.ptr_type(AddressSpace::Generic).into()),
                        BasicTypeEnum::StructType(t) => Ok(t.ptr_type(AddressSpace::Generic).into()),
                        BasicTypeEnum::ArrayType(t) => Ok(t.ptr_type(AddressSpace::Generic).into()),
                    }
                } else {
                    Err(CompilerError::code_generation_error(
                        "配列要素の型情報がありません",
                        type_ann.location.clone()
                    ))
                }
            },
            TypeKind::Named(ident) => {
                // 名前付き型の解決
                let type_name = &ident.name;
                
                if type_name == "Int" {
                    return Ok(self.context.i64_type().into());
                } else if type_name == "Float" {
                    return Ok(self.context.f64_type().into());
                } else if type_name == "Bool" {
                    return Ok(self.context.bool_type().into());
                } else if type_name == "String" {
                    return Ok(self.context.i8_type().ptr_type(AddressSpace::Generic).into());
                } else if type_name == "Char" {
                    return Ok(self.context.i8_type().into());
                }
                
                // 構造体型の解決
                if let Some(&struct_type) = self.structs.get(type_name) {
                    Ok(struct_type.into())
                } else {
                    Err(CompilerError::code_generation_error(
                        format!("未知の型名 '{}'", type_name),
                        type_ann.location.clone()
                    ))
                }
            },
            TypeKind::Function(param_types, ret_type) => {
                // 関数型はポインタとして表現
                let mut llvm_param_types = Vec::new();
                
                for param_type in param_types {
                    if let Some(param_type_info) = self.type_info.get_node_type(param_type.id) {
                        let llvm_param_type = self.convert_type_from_annotation(&param_type_info)?;
                        llvm_param_types.push(llvm_param_type);
                    } else {
                        return Err(CompilerError::code_generation_error(
                            "関数パラメータの型情報がありません",
                            type_ann.location.clone()
                        ));
                    }
                }
                
                // 戻り値型の解決
                let ret_type_info = self.type_info.get_node_type(ret_type.id).ok_or_else(|| {
                    CompilerError::code_generation_error(
                        "関数戻り値型の型情報がありません",
                        type_ann.location.clone()
                    )
                })?;
                
                let llvm_ret_type = match ret_type_info.kind {
                    TypeKind::Void => AnyTypeEnum::VoidType(self.context.void_type()),
                    _ => {
                        let basic_type = self.convert_type_from_annotation(&ret_type_info)?;
                        basic_type.into()
                    }
                };
                
                // 関数型の作成
                let fn_type = match llvm_ret_type {
                    AnyTypeEnum::VoidType(t) => t.fn_type(&llvm_param_types, false),
                    AnyTypeEnum::IntType(t) => t.fn_type(&llvm_param_types, false),
                    AnyTypeEnum::FloatType(t) => t.fn_type(&llvm_param_types, false),
                    AnyTypeEnum::PointerType(t) => t.fn_type(&llvm_param_types, false),
                    AnyTypeEnum::StructType(t) => t.fn_type(&llvm_param_types, false),
                    AnyTypeEnum::ArrayType(t) => t.fn_type(&llvm_param_types, false),
                    _ => {
                        return Err(CompilerError::code_generation_error(
                            "サポートされていない関数戻り値型です",
                            type_ann.location.clone()
                        ));
                    }
                };
                
                // 関数型はポインタとして表現
                Ok(fn_type.ptr_type(AddressSpace::Generic).into())
            },
            // その他の型も必要に応じて追加
            _ => Err(CompilerError::code_generation_error(
                format!("サポートされていない型です: {:?}", type_ann.kind),
                type_ann.location.clone()
            )),
        }
    }
    
    /// NodeIdに関連付けられた型からLLVM型に変換
    fn convert_type(&self, node_id: NodeId) -> Result<BasicTypeEnum<'ctx>> {
        if let Some(type_ann) = self.type_info.get_node_type(node_id) {
            self.convert_type_from_annotation(&type_ann)
        } else {
            Err(CompilerError::code_generation_error(
                format!("ノードID {}の型情報が見つかりません", node_id),
                None
            ))
        }
    }
    
    /// TypeAnnotationからIR型に変換
    fn convert_to_ir_type(&self, type_ann: &TypeAnnotation) -> Result<Type> {
        match &type_ann.kind {
            TypeKind::Primitive(PrimitiveType::Int) => Ok(Type::Integer(64)),
            TypeKind::Primitive(PrimitiveType::Float) => Ok(Type::Double),
            TypeKind::Primitive(PrimitiveType::Bool) => Ok(Type::Boolean),
            TypeKind::Primitive(PrimitiveType::Char) => Ok(Type::Character),
            TypeKind::Primitive(PrimitiveType::String) => Ok(Type::String),
            TypeKind::Primitive(PrimitiveType::Void) => Ok(Type::Void),
            
            TypeKind::Named(name) => {
                let type_name = &name.name;
                
                // 構造体の場合
                if self.module.structs.contains_key(type_name) {
                    // 構造体のフィールドタイプはすでに登録済み
                    let field_types = self.module.structs.get(type_name).unwrap().clone();
                    Ok(Type::Struct(type_name.clone(), field_types))
                } else {
                    // 中間表現には存在しない構造体
                    Ok(Type::Struct(type_name.clone(), Vec::new()))
                }
            },
            TypeKind::Function(param_types, ret_type) => {
                // パラメータ型の変換
                let mut ir_param_types = Vec::new();
                
                for param_type in param_types {
                    if let Some(param_type_info) = self.type_info.get_node_type(param_type.id) {
                        let ir_param_type = self.convert_to_ir_type(&param_type_info)?;
                        ir_param_types.push(ir_param_type);
                    } else {
                        return Err(CompilerError::code_generation_error(
                            "関数パラメータの型情報がありません",
                            type_ann.location.clone()
                        ));
                    }
                }
                
                // 戻り値型の解決
                let ret_type_info = self.type_info.get_node_type(ret_type.id).ok_or_else(|| {
                    CompilerError::code_generation_error(
                        "関数戻り値型の型情報がありません",
                        type_ann.location.clone()
                    )
                })?;
                
                let ir_ret_type = self.convert_to_ir_type(&ret_type_info)?;
                
                Ok(Type::Function(ir_param_types, Box::new(ir_ret_type)))
            },
            TypeKind::Optional(inner_type) => {
                if let Some(inner_type_info) = self.type_info.get_node_type(inner_type.id) {
                    let ir_inner_type = self.convert_to_ir_type(&inner_type_info)?;
                    Ok(Type::Optional(Box::new(ir_inner_type)))
                } else {
                    Err(CompilerError::code_generation_error(
                        "オプショナル型の内部型情報がありません",
                        type_ann.location.clone()
                    ))
                }
            },
            // その他の型も必要に応じて追加
            _ => Err(CompilerError::code_generation_error(
                format!("サポートされていない型です: {:?}", type_ann.kind),
                type_ann.location.clone()
            )),
        }
    }
    
    /// BasicTypeEnumからIR型に変換
    fn convert_to_ir_type_from_basic_type(&self, basic_type: BasicTypeEnum<'ctx>) -> Result<Type> {
        match basic_type {
            BasicTypeEnum::IntType(_) => Ok(Type::Integer(64)),
            BasicTypeEnum::FloatType(_) => Ok(Type::Double),
            BasicTypeEnum::PointerType(_) => Ok(Type::Pointer(Box::new(Type::Unknown))),
            BasicTypeEnum::StructType(s) => {
                let name = s.get_name()
                    .map(|name_str| name_str.to_string_lossy().to_string())
                    .unwrap_or_else(|| "anonymous_struct".to_string());
                
                Ok(Type::Struct(name, Vec::new()))
            },
            BasicTypeEnum::ArrayType(_) => Ok(Type::Array(Box::new(Type::Unknown), 0)),
            BasicTypeEnum::VectorType(_) => Ok(Type::Array(Box::new(Type::Unknown), 0)),
        }
    }
    
    // LLVM値からIR値に変換
    fn convert_to_ir_value(&self, value: BasicValueEnum<'ctx>) -> Value {
        match value {
            BasicValueEnum::IntValue(i) => {
                if i.get_type().get_bit_width() == 1 {
                    // Booleanの場合
                    let bool_val = i.get_zero_extended_constant()
                        .map(|v| v != 0)
                        .unwrap_or(false);
                    
                    Value::Boolean(bool_val)
                } else {
                    // 整数の場合
                    let int_val = i.get_zero_extended_constant()
                        .unwrap_or(0) as i64;
                    
                    Value::Integer(int_val)
                }
            },
            BasicValueEnum::FloatValue(f) => {
                // 浮動小数点の場合
                let float_val = match f.get_constant() {
                    Some(v) => v,
                    None => 0.0
                };
                
                Value::Float(float_val)
            },
            BasicValueEnum::PointerValue(_) => {
                // ポインタは適切に扱うのが難しいため、ローカル参照として扱う
                Value::LocalRef("ptr".to_string())
            },
            BasicValueEnum::StructValue(_) => {
                // 構造体も簡単な表現を使用
                Value::Struct("struct".to_string(), Vec::new())
            },
            BasicValueEnum::ArrayValue(_) => {
                // 配列も簡単な表現を使用
                Value::Array(Vec::new())
            },
            BasicValueEnum::VectorValue(_) => {
                // ベクトルも配列として扱う
                Value::Array(Vec::new())
            },
        }
    }
    
    /// 宣言の処理
    fn generate_declaration(&mut self, declaration: &Declaration) -> Result<()> {
        match &declaration.kind {
            DeclarationKind::Function(func) => self.generate_function_declaration(func, declaration)?,
            DeclarationKind::Variable(var) => self.generate_global_variable(var, declaration)?,
            DeclarationKind::Constant(constant) => self.generate_global_constant(constant, declaration)?,
            DeclarationKind::Struct(struct_decl) => self.generate_struct_declaration(struct_decl, declaration)?,
            DeclarationKind::Enum(enum_decl) => self.generate_enum_declaration(enum_decl, declaration)?,
            DeclarationKind::Trait(trait_decl) => self.generate_trait_declaration(trait_decl, declaration)?,
            DeclarationKind::Implementation(impl_decl) => self.generate_implementation(impl_decl, declaration)?,
            DeclarationKind::TypeAlias(alias) => self.generate_type_alias(alias, declaration)?,
            DeclarationKind::Import(import) => self.generate_import(import, declaration)?,
        }
        
        Ok(())
    }
    
    /// 文の処理
    fn generate_statement(&mut self, statement: &Statement) -> Result<()> {
        match &statement.kind {
            StatementKind::Expression(expr) => {
                // 式の評価（結果は破棄される）
                self.generate_expression(expr)?;
            },
            StatementKind::Block(statements) => {
                // ブロック内の各文を評価
                for stmt in statements {
                    self.generate_statement(stmt)?;
                }
            },
            StatementKind::Declaration(decl) => {
                // 宣言を処理
                self.generate_declaration(decl)?;
            },
            StatementKind::If(condition, then_branch, else_branch) => {
                // if文の処理
                self.generate_if_statement(condition, then_branch, else_branch.as_deref())?;
            },
            StatementKind::While(condition, body) => {
                // while文の処理
                self.generate_while_statement(condition, body)?;
            },
            StatementKind::For(variable, range, body) => {
                // for文の処理
                self.generate_for_statement(variable, range, body)?;
            },
            StatementKind::Return(expr) => {
                // return文の処理
                self.generate_return_statement(Some(expr.as_ref()))?;
            },
            StatementKind::Break => {
                // break文の処理
                self.generate_break_statement()?;
            },
            StatementKind::Continue => {
                // continue文の処理
                self.generate_continue_statement()?;
            },
            // 他のケースも必要に応じて追加
        }
        
        Ok(())
    }
    
    /// 式の処理
    fn generate_expression(&mut self, expression: &Expression) -> Result<BasicValueEnum<'ctx>> {
        match &expression.kind {
            ExpressionKind::Literal(lit) => self.generate_literal(lit),
            ExpressionKind::Identifier(ident) => self.generate_identifier(ident),
            ExpressionKind::BinaryOp(op, left, right) => self.generate_binary_op(*op, left, right),
            ExpressionKind::UnaryOp(op, operand) => self.generate_unary_op(*op, operand),
            ExpressionKind::Call(callee, args) => self.generate_call(callee, args),
            ExpressionKind::MemberAccess(object, member) => self.generate_member_access(object, member),
            ExpressionKind::IndexAccess(array, index) => self.generate_index_access(array, index),
            ExpressionKind::ArrayLiteral(elements) => self.generate_array_literal(elements),
            ExpressionKind::StructLiteral(name, fields) => self.generate_struct_literal(name, fields),
            ExpressionKind::TupleLiteral(elements) => self.generate_tuple_literal(elements),
            ExpressionKind::Cast(expr, target_type) => self.generate_cast(expr, target_type),
            ExpressionKind::Lambda(params, body) => self.generate_lambda(params, body),
            ExpressionKind::BlockExpr(statements, expr) => self.generate_block_expr(statements, expr.as_deref()),
            ExpressionKind::IfExpr(cond, then_branch, else_branch) => {
                self.generate_if_expr(cond, then_branch, else_branch.as_deref())
            },
            ExpressionKind::MatchExpr(expr, arms) => self.generate_match_expr(expr, arms),
            ExpressionKind::AwaitExpr(task) => self.generate_await_expr(task),
            ExpressionKind::ResultBind(result, func) => self.generate_result_bind(result, func),
            ExpressionKind::ResultMap(result, func) => self.generate_result_map(result, func),
            ExpressionKind::TryCatchExpr(try_expr, catch_clauses) => self.generate_try_catch_expr(try_expr, catch_clauses),
            ExpressionKind::ThrowExpr(error_expr) => self.generate_throw_expr(error_expr),
            ExpressionKind::AsyncExpr(expr) => self.generate_async_call(&Expression {
                id: expr.id,
                kind: expr.as_ref().kind.clone(),
                location: expr.location.clone(),
            }, &[]),
            // その他の式も必要に応じて追加
        }
    }
    
    /// リテラルの生成
    fn generate_literal(&self, literal: &Literal) -> Result<BasicValueEnum<'ctx>> {
        match &literal.kind {
            LiteralKind::Integer(value) => {
                // 整数リテラル
                let int_type = self.context.i64_type();
                Ok(int_type.const_int(*value as u64, false).into())
            },
            LiteralKind::Float(value) => {
                // 浮動小数点リテラル
                let float_type = self.context.f64_type();
                Ok(float_type.const_float(*value).into())
            },
            LiteralKind::String(value) => {
                // 文字列リテラル
                let string_val = self.builder.build_global_string_ptr(value, "str");
                Ok(string_val.as_pointer_value().into())
            },
            LiteralKind::Char(value) => {
                // 文字リテラル
                let char_type = self.context.i8_type();
                Ok(char_type.const_int(*value as u64, false).into())
            },
            LiteralKind::Boolean(value) => {
                // 論理値リテラル
                let bool_type = self.context.bool_type();
                Ok(bool_type.const_int(*value as u64, false).into())
            },
            LiteralKind::Nil => {
                // nil値（nullポインタとして表現）
                let ptr_type = self.context.i8_type().ptr_type(AddressSpace::Generic);
                Ok(ptr_type.const_null().into())
            },
        }
    }
    
    /// 識別子の参照を生成
    fn generate_identifier(&self, ident: &Identifier) -> Result<BasicValueEnum<'ctx>> {
        // 変数参照を生成
        let var_name = &ident.name;
        
        if let Some(var_ptr) = self.variables.get(var_name) {
            // ローカル変数の場合
            let var_type = var_ptr.get_type().get_element_type();
            
            // 変数の値をロード
            let value = self.builder.build_load(*var_ptr, var_name);
            Ok(value)
        } else if let Some(func) = self.functions.get(var_name) {
            // 関数参照の場合
            Ok(func.as_global_value().as_pointer_value().into())
        } else {
            // グローバル変数や定数の場合
            if let Some(global_var) = self.llvm_module.get_global(var_name) {
                let var_type = global_var.get_type().get_element_type();
                let value = self.builder.build_load(global_var.as_pointer_value(), var_name);
                Ok(value)
            } else {
                Err(CompilerError::code_generation_error(
                    format!("未定義の識別子 '{}'", var_name),
                    ident.location.clone()
                ))
            }
        }
    }
    
    /// 二項演算の生成
    fn generate_binary_op(&self, op: BinaryOperator, left: &Expression, right: &Expression) 
    -> Result<BasicValueEnum<'ctx>> {
        let left_value = self.generate_expression(left)?;
        let right_value = self.generate_expression(right)?;
        
        // 左右のオペランドの型をチェック
        match (left_value, right_value) {
            // 整数演算
            (BasicValueEnum::IntValue(left_int), BasicValueEnum::IntValue(right_int)) => {
                let result = match op {
                    BinaryOperator::Add => self.builder.build_int_add(left_int, right_int, "addtmp"),
                    BinaryOperator::Subtract => self.builder.build_int_sub(left_int, right_int, "subtmp"),
                    BinaryOperator::Multiply => self.builder.build_int_mul(left_int, right_int, "multmp"),
                    BinaryOperator::Divide => self.builder.build_int_signed_div(left_int, right_int, "divtmp"),
                    BinaryOperator::Modulo => self.builder.build_int_signed_rem(left_int, right_int, "modtmp"),
                    
                    // 比較演算
                    BinaryOperator::Equal => {
                        let cmp = self.builder.build_int_compare(inkwell::IntPredicate::EQ, 
                                                                left_int, right_int, "eqtmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::NotEqual => {
                        let cmp = self.builder.build_int_compare(inkwell::IntPredicate::NE, 
                                                                left_int, right_int, "netmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::LessThan => {
                        let cmp = self.builder.build_int_compare(inkwell::IntPredicate::SLT, 
                                                                left_int, right_int, "slttmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::GreaterThan => {
                        let cmp = self.builder.build_int_compare(inkwell::IntPredicate::SGT, 
                                                                left_int, right_int, "sgttmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::LessThanEqual => {
                        let cmp = self.builder.build_int_compare(inkwell::IntPredicate::SLE, 
                                                                left_int, right_int, "sletmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::GreaterThanEqual => {
                        let cmp = self.builder.build_int_compare(inkwell::IntPredicate::SGE, 
                                                                left_int, right_int, "sgetmp");
                        return Ok(cmp.into());
                    },
                    
                    // 論理演算
                    BinaryOperator::LogicalAnd => {
                        // 整数としての論理積（0でない値はtrue）
                        let left_bool = self.builder.build_int_compare(
                            inkwell::IntPredicate::NE,
                            left_int,
                            left_int.get_type().const_zero(),
                            "leftbool"
                        );
                        
                        let right_bool = self.builder.build_int_compare(
                            inkwell::IntPredicate::NE,
                            right_int,
                            right_int.get_type().const_zero(),
                            "rightbool"
                        );
                        
                        let result = self.builder.build_and(left_bool, right_bool, "andtmp");
                        return Ok(result.into());
                    },
                    BinaryOperator::LogicalOr => {
                        // 整数としての論理和（0でない値はtrue）
                        let left_bool = self.builder.build_int_compare(
                            inkwell::IntPredicate::NE,
                            left_int,
                            left_int.get_type().const_zero(),
                            "leftbool"
                        );
                        
                        let right_bool = self.builder.build_int_compare(
                            inkwell::IntPredicate::NE,
                            right_int,
                            right_int.get_type().const_zero(),
                            "rightbool"
                        );
                        
                        let result = self.builder.build_or(left_bool, right_bool, "ortmp");
                        return Ok(result.into());
                    },
                    
                    // ビット演算
                    BinaryOperator::BitwiseAnd => self.builder.build_and(left_int, right_int, "andtmp"),
                    BinaryOperator::BitwiseOr => self.builder.build_or(left_int, right_int, "ortmp"),
                    BinaryOperator::BitwiseXor => self.builder.build_xor(left_int, right_int, "xortmp"),
                    BinaryOperator::LeftShift => self.builder.build_left_shift(left_int, right_int, "lshifttmp"),
                    BinaryOperator::RightShift => self.builder.build_right_shift(left_int, right_int, true, "rshifttmp"),
                    
                    // 他の演算子はサポート外
                    _ => return Err(CompilerError::code_generation_error(
                        format!("整数型に対する演算子 '{:?}' はサポートされていません", op),
                        left.location.clone()
                    ))
                };
                
                Ok(result.into())
            },
            
            // 浮動小数点演算
            (BasicValueEnum::FloatValue(left_float), BasicValueEnum::FloatValue(right_float)) => {
                let result = match op {
                    BinaryOperator::Add => self.builder.build_float_add(left_float, right_float, "addtmp"),
                    BinaryOperator::Subtract => self.builder.build_float_sub(left_float, right_float, "subtmp"),
                    BinaryOperator::Multiply => self.builder.build_float_mul(left_float, right_float, "multmp"),
                    BinaryOperator::Divide => self.builder.build_float_div(left_float, right_float, "divtmp"),
                    
                    // 比較演算
                    BinaryOperator::Equal => {
                        let cmp = self.builder.build_float_compare(inkwell::FloatPredicate::OEQ, 
                                                                 left_float, right_float, "eqtmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::NotEqual => {
                        let cmp = self.builder.build_float_compare(inkwell::FloatPredicate::ONE, 
                                                                 left_float, right_float, "netmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::LessThan => {
                        let cmp = self.builder.build_float_compare(inkwell::FloatPredicate::OLT, 
                                                                 left_float, right_float, "lttmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::GreaterThan => {
                        let cmp = self.builder.build_float_compare(inkwell::FloatPredicate::OGT, 
                                                                 left_float, right_float, "gttmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::LessThanEqual => {
                        let cmp = self.builder.build_float_compare(inkwell::FloatPredicate::OLE, 
                                                                 left_float, right_float, "letmp");
                        return Ok(cmp.into());
                    },
                    BinaryOperator::GreaterThanEqual => {
                        let cmp = self.builder.build_float_compare(inkwell::FloatPredicate::OGE, 
                                                                 left_float, right_float, "getmp");
                        return Ok(cmp.into());
                    },
                    
                    // 他の演算子はサポート外
                    _ => return Err(CompilerError::code_generation_error(
                        format!("浮動小数点型に対する演算子 '{:?}' はサポートされていません", op),
                        left.location.clone()
                    )),
                };
                
                Ok(result.into())
            },
            
            // ポインタの比較演算（文字列など）
            (BasicValueEnum::PointerValue(left_ptr), BasicValueEnum::PointerValue(right_ptr)) => {
                match op {
                    BinaryOperator::Equal => {
                        // ポインタの等価比較
                        let cmp = self.builder.build_ptr_diff(left_ptr, right_ptr, "ptrdiff");
                        let zero = self.context.i64_type().const_zero();
                        let result = self.builder.build_int_compare(
                            inkwell::IntPredicate::EQ, 
                            cmp, 
                            zero, 
                            "ptreq"
                        );
                        Ok(result.into())
                    },
                    BinaryOperator::NotEqual => {
                        // ポインタの非等価比較
                        let cmp = self.builder.build_ptr_diff(left_ptr, right_ptr, "ptrdiff");
                        let zero = self.context.i64_type().const_zero();
                        let result = self.builder.build_int_compare(
                            inkwell::IntPredicate::NE, 
                            cmp, 
                            zero, 
                            "ptrne"
                        );
                        Ok(result.into())
                    },
                    _ => Err(CompilerError::code_generation_error(
                        format!("ポインタ型に対する演算子 '{:?}' はサポートされていません", op),
                        left.location.clone()
                    )),
                }
            },
            
            // 型が混在している場合（例：整数と浮動小数点）
            (BasicValueEnum::IntValue(left_int), BasicValueEnum::FloatValue(right_float)) => {
                // 整数を浮動小数点に変換して演算
                let left_float = self.builder.build_signed_int_to_float(
                    left_int, 
                    self.context.f64_type(), 
                    "inttofloat"
                );
                
                // 再帰的に浮動小数点演算を実行
                self.generate_binary_op(
                    op,
                    &Expression {
                        id: ast::generate_id(),
                        kind: ExpressionKind::Literal(Literal {
                            id: ast::generate_id(),
                            kind: LiteralKind::Float(match left_float.get_constant() {
                                Some(v) => v,
                                None => 0.0
                            }),
                            location: left.location.clone(),
                        }),
                        location: left.location.clone(),
                    },
                    &Expression {
                        id: ast::generate_id(),
                        kind: ExpressionKind::Literal(Literal {
                            id: ast::generate_id(),
                            kind: LiteralKind::Float(match right_float.get_constant() {
                                Some(v) => v,
                                None => 0.0
                            }),
                            location: right.location.clone(),
                        }),
                        location: right.location.clone(),
                    },
                )
            },
            (BasicValueEnum::FloatValue(left_float), BasicValueEnum::IntValue(right_int)) => {
                // 整数を浮動小数点に変換して演算
                let right_float = self.builder.build_signed_int_to_float(
                    right_int, 
                    self.context.f64_type(), 
                    "inttofloat"
                );
                
                // 再帰的に浮動小数点演算を実行
                self.generate_binary_op(
                    op,
                    &Expression {
                        id: ast::generate_id(),
                        kind: ExpressionKind::Literal(Literal {
                            id: ast::generate_id(),
                            kind: LiteralKind::Float(match left_float.get_constant() {
                                Some(v) => v,
                                None => 0.0
                            }),
                            location: left.location.clone(),
                        }),
                        location: left.location.clone(),
                    },
                    &Expression {
                        id: ast::generate_id(),
                        kind: ExpressionKind::Literal(Literal {
                            id: ast::generate_id(),
                            kind: LiteralKind::Float(match right_float.get_constant() {
                                Some(v) => v,
                                None => 0.0
                            }),
                            location: right.location.clone(),
                        }),
                        location: right.location.clone(),
                    },
                )
            },
            
            // その他の型の組み合わせ
            _ => Err(CompilerError::code_generation_error(
                format!("演算子 '{:?}' に対して互換性のない型です", op),
                left.location.clone()
            )),
        }
    }
    
    /// 単項演算の生成
    fn generate_unary_op(&self, op: UnaryOperator, operand: &Expression) -> Result<BasicValueEnum<'ctx>> {
        let operand_value = self.generate_expression(operand)?;
        
        match operand_value {
            // 整数演算
            BasicValueEnum::IntValue(int_val) => {
                match op {
                    UnaryOperator::Plus => {
                        // 単項プラスは値をそのまま返す
                        Ok(int_val.into())
                    },
                    UnaryOperator::Minus => {
                        // 単項マイナスは0から引く
                        let zero = int_val.get_type().const_zero();
                        let result = self.builder.build_int_sub(zero, int_val, "negtmp");
                        Ok(result.into())
                    },
                    UnaryOperator::Not => {
                        // 論理否定（0でない値はtrueと見なし、その否定を返す）
                        let zero = int_val.get_type().const_zero();
                        let is_nonzero = self.builder.build_int_compare(
                            inkwell::IntPredicate::NE, 
                            int_val, 
                            zero, 
                            "isnonzero"
                        );
                        let result = self.builder.build_not(is_nonzero, "nottmp");
                        Ok(result.into())
                    },
                    UnaryOperator::BitwiseNot => {
                        // ビット否定
                        let result = self.builder.build_not(int_val, "bnottmp");
                        Ok(result.into())
                    },
                }
            },
            // 浮動小数点演算
            BasicValueEnum::FloatValue(float_val) => {
                match op {
                    UnaryOperator::Plus => {
                        // 単項プラスは値をそのまま返す
                        Ok(float_val.into())
                    },
                    UnaryOperator::Minus => {
                        // 単項マイナスは符号を反転
                        let result = self.builder.build_float_neg(float_val, "fneg");
                        Ok(result.into())
                    },
                    _ => Err(CompilerError::code_generation_error(
                        format!("浮動小数点型に対する単項演算子 '{:?}' はサポートされていません", op),
                        operand.location.clone()
                    )),
                }
            },
            // その他の型
            _ => Err(CompilerError::code_generation_error(
                format!("単項演算子 '{:?}' にサポートされていない型です", op),
                operand.location.clone()
            )),
        }
    }
    
    /// 関数呼び出しの生成
    fn generate_call(&self, callee: &Expression, args: &[Expression]) -> Result<BasicValueEnum<'ctx>> {
        // 関数値を評価
        let callee_value = match self.generate_expression(callee)? {
            BasicValueEnum::PointerValue(ptr) => ptr,
            _ => return Err(CompilerError::code_generation_error(
                "呼び出し対象が関数ではありません",
                callee.location.clone()
            )),
        };
        
        // 関数の型情報を取得
        let fn_type = match callee_value.get_type().get_element_type() {
            AnyTypeEnum::FunctionType(ft) => ft,
            _ => return Err(CompilerError::code_generation_error(
                "呼び出し対象が関数型ではありません",
                callee.location.clone()
            )),
        };
        
        // 引数を評価
        let mut arg_values = Vec::with_capacity(args.len());
        for arg in args {
            let arg_value = self.generate_expression(arg)?;
            arg_values.push(arg_value.into());
        }
        
        // 関数呼び出し
        let result = self.builder.build_call(callee_value, &arg_values, "calltmp");
        
        // 戻り値の型を確認
        if let Some(ret_value) = result.try_as_basic_value().left() {
            Ok(ret_value)
        } else {
            // void型の関数の場合はダミー値を返す
            Ok(self.context.i32_type().const_zero().into())
        }
    }
    
    /// メンバーアクセスの生成
    fn generate_member_access(&self, object: &Expression, member: &Identifier) -> Result<BasicValueEnum<'ctx>> {
        // オブジェクトを評価
        let object_value = self.generate_expression(object)?;
        
        // オブジェクトがポインタでない場合はエラー
        let object_ptr = match object_value {
            BasicValueEnum::PointerValue(ptr) => ptr,
            _ => return Err(CompilerError::code_generation_error(
                "メンバーアクセスはポインタ型のみサポートされています",
                object.location.clone()
            )),
        };
        
        // 構造体型を解決
        let struct_type = match object_ptr.get_type().get_element_type() {
            AnyTypeEnum::StructType(st) => st,
            _ => return Err(CompilerError::code_generation_error(
                "メンバーアクセスは構造体型のみサポートされています",
                object.location.clone()
            )),
        };
        
        // 構造体名を取得
        let struct_name = struct_type.get_name()
            .map(|name_str| name_str.to_string_lossy().to_string())
            .ok_or_else(|| CompilerError::code_generation_error(
                "名前のない構造体型にはアクセスできません",
                object.location.clone()
            ))?;
        
        // フィールドインデックスを探す
        let field_index = self.find_struct_field_index(&struct_name, &member.name)
            .ok_or_else(|| CompilerError::code_generation_error(
                format!("構造体 '{}' にフィールド '{}' が見つかりません", struct_name, member.name),
                member.location.clone()
            ))?;
        
        // フィールドへのアクセスを生成
        unsafe {
            let field_ptr = self.builder.build_struct_gep(
                object_ptr,
                field_index as u32,
                &format!("{}.{}", struct_name, member.name)
            ).map_err(|e| CompilerError::code_generation_error(
                format!("フィールド '{}' へのアクセス失敗: {}", member.name, e),
                member.location.clone()
            ))?;
            // フィールドの値をロード
            let field_type = struct_type.get_field_type_at_index(field_index as u32)
                .ok_or_else(|| CompilerError::code_generation_error(
                    format!("フィールド '{}' の型情報が見つかりません", member.name),
                    member.location.clone()
                ))?;
            
            let value = self.builder.build_load(field_ptr, &member.name);
            Ok(value)
        }
    }
    
    /// 構造体のフィールドインデックスを探す
    fn find_struct_field_index(&self, struct_name: &str, field_name: &str) -> Option<usize> {
        if let Some(fields) = self.module.structs.get(struct_name) {
            // 中間表現の構造体フィールド情報を使用
            for (i, (name, _)) in fields.iter().enumerate() {
                if name == field_name {
                    return Some(i);
                }
            }
        }
        
        None
    }
    
    /// 配列インデックスアクセスの生成
    fn generate_index_access(&self, array: &Expression, index: &Expression) -> Result<BasicValueEnum<'ctx>> {
        // 配列を評価
        let array_value = self.generate_expression(array)?;
        
        // インデックスを評価
        let index_value = match self.generate_expression(index)? {
            BasicValueEnum::IntValue(i) => i,
            _ => return Err(CompilerError::code_generation_error(
                "配列インデックスは整数型でなければなりません",
                index.location.clone()
            )),
        };
        
        // 配列がポインタでない場合はエラー
        let array_ptr = match array_value {
            BasicValueEnum::PointerValue(ptr) => ptr,
            _ => return Err(CompilerError::code_generation_error(
                "インデックスアクセスはポインタ型のみサポートされています",
                array.location.clone()
            )),
        };
        
        // 要素へのアクセスを生成
        let element_ptr = unsafe {
            self.builder.build_gep(
                array_ptr.get_type().get_element_type(),
                array_ptr,
                &[index_value],
                "arrayelement"
            )
        };
        
        // 要素の値をロード
        let element_type = match array_ptr.get_type().get_element_type() {
            AnyTypeEnum::ArrayType(at) => at.get_element_type(),
            _ => return Err(CompilerError::code_generation_error(
                "インデックスアクセスは配列型のみサポートされています",
                array.location.clone()
            )),
        };
        
        let value = self.builder.build_load(element_ptr, "indexload");
        Ok(value)
    }

    /// 配列リテラルの生成
    fn generate_array_literal(&self, elements: &[Expression]) -> Result<BasicValueEnum<'ctx>> {
        if elements.is_empty() {
            return Err(CompilerError::code_generation_error(
                "空の配列リテラルはサポートされていません",
                None
            ));
        }
        
        // 最初の要素から配列の型を決定
        let first_element = self.generate_expression(&elements[0])?;
        let element_type = first_element.get_type();
        
        // 要素の値を評価
        let mut element_values = Vec::with_capacity(elements.len());
        for element in elements {
            let element_value = self.generate_expression(element)?;
            
            // 型が一致するか確認
            if element_value.get_type() != element_type {
                return Err(CompilerError::code_generation_error(
                    "配列リテラルの要素の型が一致しません",
                    element.location.clone()
                ));
            }
            
            element_values.push(element_value);
        }
        
        // 配列型の作成
        let array_type = element_type.array_type(elements.len() as u32);
        
        // スタック上に配列を確保
        let array_alloca = self.builder.build_alloca(array_type, "arrayliteral");
        
        // 各要素を配列に格納
        for (i, value) in element_values.iter().enumerate() {
            let i32_type = self.context.i32_type();
            let idx = i32_type.const_int(i as u64, false);
            
            // 要素のポインタを取得
            let element_ptr = unsafe {
                self.builder.build_gep(
                    array_type,
                    array_alloca,
                    &[i32_type.const_zero(), idx],
                    &format!("array.{}", i)
                )
            };
            
            // 要素を格納
            self.builder.build_store(element_ptr, *value);
        }
        
        Ok(array_alloca.into())
    }

    /// 構造体リテラルの生成
    fn generate_struct_literal(&self, name: &Identifier, fields: &[(Identifier, Expression)]) -> Result<BasicValueEnum<'ctx>> {
        // 構造体型を取得
        let struct_name = &name.name;
        let struct_type = match self.structs.get(struct_name) {
            Some(st) => *st,
            None => return Err(CompilerError::code_generation_error(
                format!("未定義の構造体型 '{}'", struct_name),
                name.location.clone()
            )),
        };
        
        // 構造体のインスタンスを確保
        let struct_alloca = self.builder.build_alloca(struct_type, &format!("{}_instance", struct_name));
        
        // モジュールの構造体フィールド情報を取得
        let field_infos = self.module.structs.get(struct_name).ok_or_else(|| 
            CompilerError::code_generation_error(
                format!("構造体 '{}' のフィールド情報が見つかりません", struct_name),
                name.location.clone()
            )
        )?;
        
        // フィールドの初期化
        for (field_name, field_value) in fields {
            // フィールドのインデックスを取得
            let field_index = self.find_struct_field_index(struct_name, &field_name.name)
                .ok_or_else(|| CompilerError::code_generation_error(
                    format!("構造体 '{}' にフィールド '{}' が見つかりません", struct_name, field_name.name),
                    field_name.location.clone()
                ))?;
            
            // フィールド値を評価
            let value = self.generate_expression(field_value)?;
            
            // フィールドに値を格納
            unsafe {
                let field_ptr = self.builder.build_struct_gep(
                    struct_type,
                    struct_alloca, 
                    field_index as u32, 
                    &format!("{}.{}", struct_name, field_name.name)
                ).map_err(|_| CompilerError::code_generation_error(
                    format!("フィールド '{}' へのアクセス中にエラーが発生しました", field_name.name),
                    field_name.location.clone()
                ))?;
                
                self.builder.build_store(field_ptr, value);
            }
        }
        
        Ok(struct_alloca.into())
    }

    /// タプルリテラルの生成
    fn generate_tuple_literal(&self, elements: &[Expression]) -> Result<BasicValueEnum<'ctx>> {
        // 要素の型と値を評価
        let mut element_values = Vec::with_capacity(elements.len());
        let mut element_types = Vec::with_capacity(elements.len());
        
        for element in elements {
            let value = self.generate_expression(element)?;
            element_types.push(value.get_type());
            element_values.push(value);
        }
        
        // タプル型を作成
        let tuple_type = self.context.struct_type(&element_types, false);
        
        // スタック上にタプルを確保
        let tuple_alloca = self.builder.build_alloca(tuple_type, "tupleliteral");
        
        // 各要素をタプルに格納
        for (i, value) in element_values.iter().enumerate() {
            // 要素のポインタを取得
            let element_ptr = unsafe {
                self.builder.build_struct_gep(
                    tuple_type,
                    tuple_alloca,
                    i as u32,
                    &format!("tuple.{}", i)
                ).map_err(|_| CompilerError::code_generation_error(
                    format!("タプル要素 {} へのアクセス中にエラーが発生しました", i),
                    elements[i].location.clone()
                ))?
            };
            
            // 要素を格納
            self.builder.build_store(element_ptr, *value);
        }
        
        Ok(tuple_alloca.into())
    }

    /// 型キャストの生成
    fn generate_cast(&self, expr: &Expression, target_type: &TypeAnnotation) -> Result<BasicValueEnum<'ctx>> {
        // 式を評価
        let expr_value = self.generate_expression(expr)?;
        
        // ターゲット型を取得
        let target_llvm_type = self.convert_type_from_annotation(target_type)?;
        
        // 型に応じたキャスト処理
        match (expr_value, target_llvm_type) {
            // 整数から整数へのキャスト
            (BasicValueEnum::IntValue(int_val), BasicTypeEnum::IntType(target_int_type)) => {
                let source_bit_width = int_val.get_type().get_bit_width();
                let target_bit_width = target_int_type.get_bit_width();
                
                let result = if target_bit_width > source_bit_width {
                    // 拡張
                    self.builder.build_int_s_extend_or_bit_cast(int_val, target_int_type, "intext")
                } else if target_bit_width < source_bit_width {
                    // 縮小
                    self.builder.build_int_truncate(int_val, target_int_type, "inttrunc")
                } else {
                    // 同じビット幅の場合はそのまま
                    int_val
                };
                
                Ok(result.into())
            },
            
            // 整数から浮動小数点へのキャスト
            (BasicValueEnum::IntValue(int_val), BasicTypeEnum::FloatType(float_type)) => {
                let result = self.builder.build_signed_int_to_float(int_val, float_type, "inttofloat");
                Ok(result.into())
            },
            
            // 浮動小数点から整数へのキャスト
            (BasicValueEnum::FloatValue(float_val), BasicTypeEnum::IntType(int_type)) => {
                let result = self.builder.build_float_to_signed_int(float_val, int_type, "floattoint");
                Ok(result.into())
            },
            
            // 浮動小数点から浮動小数点へのキャスト（精度変換）
            (BasicValueEnum::FloatValue(float_val), BasicTypeEnum::FloatType(target_float_type)) => {
                let source_width = float_val.get_type().get_bit_width();
                let target_width = target_float_type.get_bit_width();
                
                let result = if target_width > source_width {
                    // 拡張（例: f32 -> f64）
                    self.builder.build_float_ext(float_val, target_float_type, "floatext")
                } else if target_width < source_width {
                    // 縮小（例: f64 -> f32）
                    self.builder.build_float_trunc(float_val, target_float_type, "floattrunc")
                } else {
                    // 同じサイズの場合はそのまま
                    float_val
                };
                
                Ok(result.into())
            },
            
            // ポインタ間のキャスト
            (BasicValueEnum::PointerValue(ptr_val), BasicTypeEnum::PointerType(target_ptr_type)) => {
                let result = self.builder.build_pointer_cast(ptr_val, target_ptr_type, "ptrcast");
                Ok(result.into())
            },
            
            // ポインタと整数間のキャスト
            (BasicValueEnum::PointerValue(ptr_val), BasicTypeEnum::IntType(int_type)) => {
                let result = self.builder.build_ptr_to_int(ptr_val, int_type, "ptrtoint");
                Ok(result.into())
            },
            (BasicValueEnum::IntValue(int_val), BasicTypeEnum::PointerType(ptr_type)) => {
                let result = self.builder.build_int_to_ptr(int_val, ptr_type, "inttoptr");
                Ok(result.into())
            },
            
            // その他の型変換はサポート外
            _ => Err(CompilerError::code_generation_error(
                format!("サポートされていない型変換です: {:?} -> {:?}", expr_value.get_type(), target_llvm_type),
                expr.location.clone()
            )),
        }
    }

    /// ラムダ式の生成
    fn generate_lambda(&mut self, params: &[Parameter], body: &Expression) -> Result<BasicValueEnum<'ctx>> {
        // 一意なラムダ関数名を生成
        let lambda_name = self.generate_temp_name("lambda");
        
        // 現在の関数と基本ブロックを保存
        let old_function = self.current_function;
        let old_block = self.current_block;
        let old_variables = std::mem::take(&mut self.variables);
        
        // パラメータの型を解決
        let mut param_types = Vec::with_capacity(params.len());
        for param in params {
            let param_type = if let Some(type_ann) = &param.type_annotation {
                self.convert_type_from_annotation(type_ann)?
            } else {
                // 型注釈がない場合は推論（ここでは仮にi64を使用）
                self.context.i64_type().into()
            };
            param_types.push(param_type);
        }
        
        // ラムダの戻り値型を推論
        let return_type = match self.type_info.get_node_type(body.id) {
            Some(ty) => self.convert_type_from_annotation(ty)?,
            None => self.context.void_type().into(), // デフォルトはvoid
        };
        
        // 関数型の作成
        let fn_type = match return_type {
            BasicTypeEnum::IntType(t) => t.fn_type(&param_types, false),
            BasicTypeEnum::FloatType(t) => t.fn_type(&param_types, false),
            BasicTypeEnum::PointerType(t) => t.fn_type(&param_types, false),
            BasicTypeEnum::StructType(t) => t.fn_type(&param_types, false),
            BasicTypeEnum::ArrayType(t) => t.fn_type(&param_types, false),
            BasicTypeEnum::VectorType(t) => t.fn_type(&param_types, false),
        };
        
        // 関数を作成
        let function = self.llvm_module.add_function(&lambda_name, fn_type, None);
        
        // エントリーブロックを作成
        let entry_block = self.context.append_basic_block(function, "entry");
        self.builder.position_at_end(entry_block);
        
        // 新しい関数コンテキストを設定
        self.current_function = Some(function);
        self.current_block = Some(entry_block);
        
        // パラメータを登録
        for (i, param) in params.iter().enumerate() {
            let param_value = function.get_nth_param(i as u32)
                .ok_or_else(|| CompilerError::code_generation_error(
                    format!("パラメータ {} が見つかりません", i),
                    param.location.clone()
                ))?;
            
            // パラメータ用のスタック変数を作成してストア
            let param_ptr = self.builder.build_alloca(param_value.get_type(), &param.name.name);
            self.builder.build_store(param_ptr, param_value);
            self.variables.insert(param.name.name.clone(), param_ptr);
        }
        
        // ラムダ本体を生成
        let body_value = self.generate_expression(body)?;
        
        // 戻り値を設定
        if !return_type.is_void_type() {
            self.builder.build_return(Some(&body_value));
        } else {
            self.builder.build_return(None);
        }
        
        // 関数コンテキストを復元
        self.current_function = old_function;
        self.current_block = old_block;
        self.variables = old_variables;
        
        // 関数ポインタを返す
        Ok(function.as_global_value().as_pointer_value().into())
    }

    /// ブロック式の生成
    fn generate_block_expr(&mut self, statements: &[Statement], final_expr: Option<&Expression>) -> Result<BasicValueEnum<'ctx>> {
        // 現在の変数環境を保存
        let old_variables = self.variables.clone();
        
        // ブロック内の各文を生成
        for stmt in statements {
            self.generate_statement(stmt)?;
        }
        
        // 最終式があれば評価し、その値を返す
        let result = if let Some(expr) = final_expr {
            self.generate_expression(expr)?
        } else {
            // 最終式がない場合はvoid値（ダミーの整数値）を返す
            self.context.i32_type().const_zero().into()
        };
        
        // 元の変数環境を復元（ブロックスコープから外れた変数を削除）
        // ただし、外側のスコープで定義された変数は保持
        let mut new_variables = HashMap::new();
        for (name, ptr) in old_variables {
            if self.variables.contains_key(&name) {
                new_variables.insert(name, ptr);
            }
        }
        self.variables = new_variables;
        
        Ok(result)
    }
    
    /// if文の生成
    fn generate_if_statement(&mut self, condition: &Expression, then_branch: &Statement, else_branch: Option<&Statement>) -> Result<()> {
        // 条件を評価
        let cond_value = self.generate_expression(condition)?;
        
        // 条件をブール値に変換（必要に応じて）
        let cond_bool = match cond_value {
            BasicValueEnum::IntValue(int_val) => {
                // 整数値を比較（0でない値はtrue）
                let zero = int_val.get_type().const_zero();
                self.builder.build_int_compare(
                    inkwell::IntPredicate::NE,
                    int_val,
                    zero,
                    "ifcond"
                )
            },
            _ => {
                return Err(CompilerError::code_generation_error(
                    "if文の条件にはブール型または整数型が必要です",
                    condition.location.clone()
                ));
            }
        };
        
        // 現在の関数
        let current_fn = self.current_function.ok_or_else(|| {
            CompilerError::code_generation_error(
                "関数コンテキスト外でのif文は無効です",
                condition.location.clone()
            )
        })?;
        
        // 分岐先の基本ブロックを作成
        let then_block = self.context.append_basic_block(current_fn, "then");
        let else_block = self.context.append_basic_block(current_fn, "else");
        let merge_block = self.context.append_basic_block(current_fn, "ifcont");
        
        // 条件に基づいて分岐
        self.builder.build_conditional_branch(cond_bool, then_block, else_block);
        
        // then部分の生成
        self.builder.position_at_end(then_block);
        self.current_block = Some(then_block);
        self.generate_statement(then_branch)?;
        
        // then部分の最後に無条件分岐を追加（fallthroughを防ぐ）
        if !self.builder.get_insert_block().unwrap().get_terminator().is_some() {
            self.builder.build_unconditional_branch(merge_block);
        }
        
        // else部分の生成
        self.builder.position_at_end(else_block);
        self.current_block = Some(else_block);
        if let Some(else_stmt) = else_branch {
            self.generate_statement(else_stmt)?;
        }
        
        // else部分の最後に無条件分岐を追加
        if !self.builder.get_insert_block().unwrap().get_terminator().is_some() {
            self.builder.build_unconditional_branch(merge_block);
        }
        
        // マージブロックに移動
        self.builder.position_at_end(merge_block);
        self.current_block = Some(merge_block);
        
        // 条件評価後に分岐インストルメンテーション
        let branch_id = self.generate_temp_name("if_branch");
        self.generate_branch_instrumentation(cond_bool, &branch_id)?;
        
        Ok(())
    }
    
    /// if式の生成
    fn generate_if_expr(&mut self, condition: &Expression, then_branch: &Expression, else_branch: Option<&Expression>) -> Result<BasicValueEnum<'ctx>> {
        // 条件を評価
        let cond_value = self.generate_expression(condition)?;
        
        // 条件をブール値に変換（必要に応じて）
        let cond_bool = match cond_value {
            BasicValueEnum::IntValue(int_val) => {
                // 整数値を比較（0でない値はtrue）
                let zero = int_val.get_type().const_zero();
                self.builder.build_int_compare(
                    inkwell::IntPredicate::NE,
                    int_val,
                    zero,
                    "ifcond"
                )
            },
            _ => {
                return Err(CompilerError::code_generation_error(
                    "if式の条件にはブール型または整数型が必要です",
                    condition.location.clone()
                ));
            }
        };
        
        // 現在の関数
        let current_fn = self.current_function.ok_or_else(|| {
            CompilerError::code_generation_error(
                "関数コンテキスト外でのif式は無効です",
                condition.location.clone()
            )
        })?;
        
        // then部分の型を調べて戻り値の型を決定
        let then_result_type = self.type_info.get_node_type(then_branch.id)
            .ok_or_else(|| CompilerError::code_generation_error(
                "if式のthen部分の型情報が見つかりません",
                then_branch.location.clone()
            ))?;
        
        let result_type = self.convert_type_from_annotation(then_result_type)?;
        
        // 分岐先の基本ブロックを作成
        let then_block = self.context.append_basic_block(current_fn, "then");
        let else_block = self.context.append_basic_block(current_fn, "else");
        let merge_block = self.context.append_basic_block(current_fn, "ifcont");
        
        // 条件に基づいて分岐
        self.builder.build_conditional_branch(cond_bool, then_block, else_block);
        
        // phi節点用の値を格納するための変数
        let mut incoming_values = Vec::new();
        let mut incoming_blocks = Vec::new();
        
        // then部分の生成
        self.builder.position_at_end(then_block);
        self.current_block = Some(then_block);
        let then_value = self.generate_expression(then_branch)?;
        
        // then部分からの遷移元情報を記録
        incoming_values.push(then_value);
        incoming_blocks.push(self.builder.get_insert_block().unwrap());
        
        // then部分の最後に無条件分岐を追加
        self.builder.build_unconditional_branch(merge_block);
        
        // else部分の生成
        self.builder.position_at_end(else_block);
        self.current_block = Some(else_block);
        
        let else_value = if let Some(else_expr) = else_branch {
            self.generate_expression(else_expr)?
        } else {
            // else部分がない場合はデフォルト値を使用
            match result_type {
                BasicTypeEnum::IntType(t) => t.const_zero().into(),
                BasicTypeEnum::FloatType(t) => t.const_zero().into(),
                BasicTypeEnum::PointerType(t) => t.const_null().into(),
                BasicTypeEnum::StructType(_) => {
                    return Err(CompilerError::code_generation_error(
                        "if式のelse部分が省略されている場合、構造体型は返せません",
                        condition.location.clone()
                    ));
                },
                BasicTypeEnum::ArrayType(_) => {
                    return Err(CompilerError::code_generation_error(
                        "if式のelse部分が省略されている場合、配列型は返せません",
                        condition.location.clone()
                    ));
                },
                BasicTypeEnum::VectorType(_) => {
                    return Err(CompilerError::code_generation_error(
                        "if式のelse部分が省略されている場合、ベクトル型は返せません",
                        condition.location.clone()
                    ));
                },
            }
        };
        
        // else部分からの遷移元情報を記録
        incoming_values.push(else_value);
        incoming_blocks.push(self.builder.get_insert_block().unwrap());
        
        // else部分の最後に無条件分岐を追加
        self.builder.build_unconditional_branch(merge_block);
        
        // マージブロックに移動してPhi節点を作成
        self.builder.position_at_end(merge_block);
        self.current_block = Some(merge_block);
        
        // Phi節点を作成
        let phi = self.builder.build_phi(result_type, "ifresult");
        
        // Phi節点に値を追加
        for (value, block) in incoming_values.iter().zip(incoming_blocks.iter()) {
            phi.add_incoming(&[(&*value, *block)]);
        }
        
        Ok(phi.as_basic_value())
    }

    /// match式の生成
    fn generate_match_expr(&mut self, expr: &Expression, arms: &[(Expression, Expression)]) -> Result<BasicValueEnum<'ctx>> {
        // 対象式の評価
        let expr_value = self.generate_expression(expr)?;
        
        // 現在の関数
        let current_fn = self.current_function.ok_or_else(|| {
            CompilerError::code_generation_error(
                "関数コンテキスト外でのmatch式は無効です",
                expr.location.clone()
            )
        })?;
        
        // 最初のアームの結果の型を推論してmatch式の戻り値の型を決定
        if arms.is_empty() {
            return Err(CompilerError::code_generation_error(
                "match式には少なくとも1つのアームが必要です",
                expr.location.clone()
            ));
        }
        
        let first_arm_type = self.type_info.get_node_type(arms[0].1.id)
            .ok_or_else(|| CompilerError::code_generation_error(
                "match式のアームの型情報が見つかりません",
                arms[0].1.location.clone()
            ))?;
        
        let result_type = self.convert_type_from_annotation(first_arm_type)?;
        
        // 終了ブロック（全アームの合流先）
        let merge_block = self.context.append_basic_block(current_fn, "matchend");
        
        // phi節点用の値を格納するための変数
        let mut incoming_values = Vec::new();
        let mut incoming_blocks = Vec::new();
        
        // デフォルトのケース（すべてのパターンにマッチしなかった場合）
        let default_block = self.context.append_basic_block(current_fn, "match_default");
        
        // 前のアームの次のチェックブロック（最初はここから開始）
        let mut current_block = self.builder.get_insert_block().unwrap();
        self.builder.position_at_end(current_block);
        
        // マッチ対象の値を一時変数に保存（複数回評価を避けるため）
        let expr_type = expr_value.get_type();
        let expr_ptr = self.builder.build_alloca(expr_type, "match_expr_var");
        self.builder.build_store(expr_ptr, expr_value);
        
        // 各アームごとにブロックを生成
        for (i, (pattern, arm_body)) in arms.iter().enumerate() {
            // このパターンのブロック
            let pattern_block = self.context.append_basic_block(current_fn, &format!("match_arm{}", i));
            // 次のパターンチェックのブロック（最後のアームの場合はデフォルトブロック）
            let next_pattern_block = if i == arms.len() - 1 {
                default_block
            } else {
                self.context.append_basic_block(current_fn, &format!("match_check{}", i + 1))
            };
            
            // パターンマッチのチェックコードをこのブロックに配置
            self.builder.position_at_end(current_block);
            
            match &pattern.kind {
                // リテラルパターン
                ExpressionKind::Literal(lit) => {
                    // リテラル値を評価
                    let lit_value = self.generate_literal(lit)?;
                    
                    // 対象式の値をロード
                    let expr_value = self.builder.build_load(expr_ptr, "match_expr_val");
                    
                    // 対象式の値とリテラルを比較
                    let cond = match (expr_value, lit_value) {
                        (BasicValueEnum::IntValue(expr_int), BasicValueEnum::IntValue(lit_int)) => {
                            self.builder.build_int_compare(
                                inkwell::IntPredicate::EQ,
                                expr_int,
                                lit_int,
                                "matchcmp"
                            )
                        },
                        (BasicValueEnum::FloatValue(expr_float), BasicValueEnum::FloatValue(lit_float)) => {
                            self.builder.build_float_compare(
                                inkwell::FloatPredicate::OEQ,
                                expr_float,
                                lit_float,
                                "matchcmp"
                            )
                        },
                        _ => {
                            return Err(CompilerError::code_generation_error(
                                "サポートされていないmatchパターンです",
                                pattern.location.clone()
                            ));
                        }
                    };
                    
                    // 条件によって分岐
                    self.builder.build_conditional_branch(cond, pattern_block, next_pattern_block);
                },
                
                // 識別子パターン（変数バインディング）
                ExpressionKind::Identifier(ident) => {
                    // 対象式の値をロード
                    let expr_value = self.builder.build_load(expr_ptr, "match_expr_val");
                    
                    // 現在のスコープにパターン変数をバインド
                    let var_name = &ident.name;
                    let var_ptr = self.builder.build_alloca(expr_type, var_name);
                    self.builder.build_store(var_ptr, expr_value);
                    self.variables.insert(var_name.clone(), var_ptr);
                    
                    // 常にマッチする
                    self.builder.build_unconditional_branch(pattern_block);
                },
                
                // 構造体パターン（新規実装）
                ExpressionKind::StructLiteral(struct_name, fields) => {
                    // 対象式の値をロード
                    let expr_value = self.builder.build_load(expr_ptr, "match_expr_val");
                    
                    // 構造体型かチェック
                    if let BasicValueEnum::StructValue(struct_val) = expr_value {
                        let struct_type = struct_val.get_type();
                        let struct_name_str = &struct_name.name;
                        
                        // 一時変数に保存
                        let struct_ptr = self.builder.build_alloca(struct_type, "struct_pattern");
                        self.builder.build_store(struct_ptr, struct_val);
                        
                        // マッチ条件ブロックの開始
                        let mut current_match_block = self.builder.get_insert_block().unwrap();
                        let mut all_fields_match = true;
                        
                        // 各フィールドのパターンマッチ
                        for (field_name, field_pattern) in fields {
                            // フィールドのインデックスを取得
                            let field_idx = self.find_struct_field_index(struct_name_str, &field_name.name);
                            
                            if let Some(idx) = field_idx {
                                // フィールド値へのアクセス
                                let field_ptr = unsafe {
                                    self.builder.build_struct_gep(
                                        struct_ptr,
                                        idx as u32,
                                        &format!("{}_ptr", field_name.name)
                                    )?
                                };
                                
                                // フィールドが識別子パターンの場合（変数バインド）
                                if let ExpressionKind::Identifier(pattern_var) = &field_pattern.kind {
                                    // フィールド値をロード
                                    let field_value = self.builder.build_load(
                                        self.builder.get_insert_block().unwrap().get_context().i32_type().into(),  // 仮の型
                                        field_ptr, 
                                        &format!("{}_val", field_name.name)
                                    );
                                    
                                    // 変数にバインド
                                    let var_ptr = self.builder.build_alloca(
                                        field_value.get_type(), 
                                        &pattern_var.name
                                    );
                                    self.builder.build_store(var_ptr, field_value);
                                    self.variables.insert(pattern_var.name.clone(), var_ptr);
                                } else {
                                    // より複雑なネストしたパターンマッチは省略（実際の実装ではここに再帰的なマッチング処理が必要）
                                    all_fields_match = false;
                                    break;
                                }
                            } else {
                                // フィールドが見つからない
                                all_fields_match = false;
                                break;
                            }
                        }
                        
                        // すべてのフィールドがマッチしたかどうかでブランチ
                        if all_fields_match {
                            self.builder.build_unconditional_branch(pattern_block);
                        } else {
                            self.builder.build_unconditional_branch(next_pattern_block);
                        }
                    } else {
                        // 構造体でなければ次のパターンへ
                        self.builder.build_unconditional_branch(next_pattern_block);
                    }
                },
                
                // ガード付きパターン（新規実装）- パターンと条件式のタプル
                ExpressionKind::TupleLiteral(elements) if elements.len() == 2 => {
                    // パターン部分（最初の要素）
                    let sub_pattern = &elements[0];
                    // ガード条件（2番目の要素）
                    let guard_expr = &elements[1];
                    
                    // 対象式の値をロード
                    let expr_value = self.builder.build_load(expr_ptr, "match_expr_val");
                    
                    // パターンマッチングの一時ブロック
                    let pattern_match_block = self.context.append_basic_block(current_fn, &format!("guard_pattern{}", i));
                    let guard_eval_block = self.context.append_basic_block(current_fn, &format!("guard_eval{}", i));
                    
                    // サブパターンの種類に応じたマッチング
                    match &sub_pattern.kind {
                        // 識別子パターン
                        ExpressionKind::Identifier(ident) => {
                            // 変数にバインド
                            let var_name = &ident.name;
                            let var_ptr = self.builder.build_alloca(expr_type, var_name);
                            self.builder.build_store(var_ptr, expr_value);
                            self.variables.insert(var_name.clone(), var_ptr);
                            
                            // パターンマッチブロックへ分岐
                            self.builder.build_unconditional_branch(pattern_match_block);
                        },
                        
                        // リテラルパターン
                        ExpressionKind::Literal(lit) => {
                            // リテラル値を評価
                            let lit_value = self.generate_literal(lit)?;
                            
                            // 対象式の値とリテラルを比較
                            let cond = match (expr_value, lit_value) {
                                (BasicValueEnum::IntValue(expr_int), BasicValueEnum::IntValue(lit_int)) => {
                                    self.builder.build_int_compare(
                                        inkwell::IntPredicate::EQ,
                                        expr_int,
                                        lit_int,
                                        "guardcmp"
                                    )
                                },
                                (BasicValueEnum::FloatValue(expr_float), BasicValueEnum::FloatValue(lit_float)) => {
                                    self.builder.build_float_compare(
                                        inkwell::FloatPredicate::OEQ,
                                        expr_float,
                                        lit_float,
                                        "guardcmp"
                                    )
                                },
                                _ => {
                                    return Err(CompilerError::code_generation_error(
                                        "サポートされていないmatchパターンです",
                                        sub_pattern.location.clone()
                                    ));
                                }
                            };

// ファイルを修復するための閉じ括弧
                                    }
                                };
                                
                                // 条件分岐
                                self.builder.build_conditional_branch(cond, pattern_block, next_pattern_block);
                                
                                // パターンマッチブロックでの処理
                                self.builder.position_at_end(pattern_match_block);
                                
                                // ガード条件の評価
                                let guard_val = self.generate_expression(guard_expr)?;
                                if let BasicValueEnum::IntValue(guard_int) = guard_val {
                                    // ガード条件によって分岐
                                    let cond = self.builder.build_int_compare(
                                        inkwell::IntPredicate::NE,
                                        guard_int,
                                        self.context.bool_type().const_zero(),
                                        "guard_cond"
                                    );
                                    self.builder.build_conditional_branch(cond, pattern_block, next_pattern_block);
                                } else {
                                    return Err(CompilerError::code_generation_error(
                                        "ガード条件はブール型である必要があります",
                                        guard_expr.location.clone()
                                    ));
                                }
                            }
                        }
                        _ => {
                            // その他のパターンは未サポート
                            self.builder.build_unconditional_branch(next_pattern_block);
                        }
                    };
                    
                    // パターンブロックの生成
                    self.builder.position_at_end(pattern_block);
                    
                    // アームの本体を評価
                    let arm_result = self.generate_expression(arm_body)?;
                    
                    // マージブロックに分岐
                    self.builder.build_unconditional_branch(merge_block);
                    
                    // PHI節点用に現在のブロックと値を記録
                    incoming_values.push(arm_result);
                    incoming_blocks.push(self.builder.get_insert_block().unwrap());
                    
                    // 次のブロックに位置を更新
                    current_block = next_pattern_block;
                }
                
                // デフォルトブロックの生成（マッチしなかった場合）
                self.builder.position_at_end(default_block);
                
                // デフォルトの処理（ここではエラーを返す）
                let error_msg = "どのパターンにもマッチしませんでした";
                let err_result = self.build_runtime_error(error_msg, None)?;
                self.builder.build_unreachable();
                
                // マージブロックの生成
                self.builder.position_at_end(merge_block);
                
                // PHI節点が必要な場合
                if incoming_values.len() > 0 {
                    let result_type = incoming_values[0].get_type();
                    let phi = self.builder.build_phi(result_type, "matchresult");
                    
                    for (i, value) in incoming_values.iter().enumerate() {
                        phi.add_incoming(&[(&value, incoming_blocks[i])]);
                    }
                    
                    Ok(phi.as_basic_value())
                } else {
                    // すべてエラーの場合は適当な値を返す（実行されることはない）
                    Ok(self.context.i32_type().const_zero().into())
                }
            }
        }
    }
} 